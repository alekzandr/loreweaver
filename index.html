<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LoreWeaver - D&D Exploration Encounter Generator</title>
    
    <!-- Preload critical images -->
    <link rel="preload" href="assets/img/d20.png" as="image">
    <link rel="preload" href="assets/img/character.png" as="image">
    
    <!-- CSS Modules -->
    <link rel="stylesheet" href="assets/css/base.css">
    <link rel="stylesheet" href="assets/css/themes.css">
    <link rel="stylesheet" href="assets/css/components.css">
    <link rel="stylesheet" href="assets/css/pages.css">
    <link rel="stylesheet" href="assets/css/changelog.css">
    
    <!-- Test Suites (only loaded in development) -->
    <script type="module" src="tests/test-memory-leak-event-listeners.js"></script>
    <script type="module" src="tests/test-localstorage-quota.js"></script>
    <script type="module" src="tests/test-race-condition-data-loading.js"></script>
    <script type="module" src="tests/test-duplicate-exports.js"></script>
    <script type="module" src="tests/test-panel-closing-chrome.js"></script>
    <script type="module" src="tests/test-changelog.js"></script>
    <script type="module" src="tests/test-event-bus.js"></script>
    <script type="module" src="tests/test-command-history.mjs"></script>
</head>
<body>
    <div class="main-content" id="mainContent">
        <div class="container">
            <header>
                <h1>‚öîÔ∏è LoreWeaver ‚öîÔ∏è</h1>
                <p class="subtitle">D&D Exploration Encounter Generator</p>
                
                <!-- Navigation Tabs -->
                <div class="nav-tabs">
                    <button class="nav-tab active" onclick="switchPage('generate')"><img src="assets/img/d20.png" alt="dice" class="dice-icon"> Generate</button>
                    <button class="nav-tab" onclick="switchPage('npc')"><img src="assets/img/character.png" alt="character" class="character-icon"> NPCs</button>
                    <button class="nav-tab" onclick="switchPage('search')">üîç Search</button>
                    <button class="nav-tab" onclick="switchPage('settings')">‚öôÔ∏è Settings</button>
                </div>
            </header>

            <!-- Generate Page -->
            <div id="generatePage" class="page-content">
                <div class="controls">
                    <div class="controls-grid">
                        <div class="control-group">
                            <label for="environmentSelect">Environment:</label>
                            <select id="environmentSelect" onchange="window.selectedEnvironment = this.value">
                                <option value="urban">Urban</option>
                                <option value="arctic">Arctic</option>
                                <option value="ocean">Ocean</option>
                                <option value="space">Space</option>
                                <option value="crypt">Crypt</option>
                                <option value="forest">Forest</option>
                                <option value="desert">Desert</option>
                                <option value="mountain">Mountain</option>
                                <option value="swamp">Swamp</option>
                                <option value="underground">Underground</option>
                            </select>
                        </div>

                        <div class="control-group">
                            <label for="partyLevel">Party Level:</label>
                            <select id="partyLevel">
                                <option value="1">Level 1</option>
                                <option value="2">Level 2</option>
                                <option value="3">Level 3</option>
                                <option value="4">Level 4</option>
                                <option value="5" selected>Level 5</option>
                                <option value="6">Level 6</option>
                                <option value="7">Level 7</option>
                                <option value="8">Level 8</option>
                                <option value="9">Level 9</option>
                                <option value="10">Level 10</option>
                                <option value="11">Level 11</option>
                                <option value="12">Level 12</option>
                                <option value="13">Level 13</option>
                                <option value="14">Level 14</option>
                                <option value="15">Level 15</option>
                                <option value="16">Level 16</option>
                                <option value="17">Level 17</option>
                                <option value="18">Level 18</option>
                                <option value="19">Level 19</option>
                                <option value="20">Level 20</option>
                            </select>
                        </div>

                        <div class="control-group">
                            <label for="numLocations">Locations:</label>
                            <select id="numLocations">
                                <option value="1">1 Location</option>
                                <option value="2">2 Locations</option>
                                <option value="3" selected>3 Locations</option>
                                <option value="4">4 Locations</option>
                                <option value="5">5 Locations</option>
                            </select>
                        </div>
                    </div>

                    <div class="control-group seed-actions-group">
                        <div class="seed-input-wrapper">
                            <label for="encounterSeed">Seed (optional):</label>
                            <input type="text" id="encounterSeed" placeholder="Leave empty for random, or paste seed here">
                        </div>
                        <div class="actions-wrapper">
                            <label style="visibility: hidden;">Actions</label>
                            <div class="encounter-actions">
                                <button class="actions-btn" onclick="toggleEncounterMenu(event)" id="mainActionsBtn">
                                    Actions
                                </button>
                                <div class="encounter-menu" id="encounterActionsMenu">
                                    <button class="menu-item" onclick="window.saveCurrentEncounter(); closeEncounterMenu();">
                                        <span class="menu-icon">üíæ</span>
                                        <span class="menu-text">Save</span>
                                    </button>
                                    <button class="menu-item" onclick="window.showSavedEncounters(); closeEncounterMenu();">
                                        <span class="menu-icon">üìÇ</span>
                                        <span class="menu-text">Load</span>
                                    </button>
                                    <button class="menu-item" onclick="window.exportEncounterMarkdown(); closeEncounterMenu();">
                                        <span class="menu-icon">üìù</span>
                                        <span class="menu-text">Export as Markdown</span>
                                    </button>
                                    <button class="menu-item" onclick="window.exportEncounterText(); closeEncounterMenu();">
                                        <span class="menu-icon">üìÑ</span>
                                        <span class="menu-text">Export as Text</span>
                                    </button>
                                    <button class="menu-item" onclick="window.exportEncounterJSON(); closeEncounterMenu();">
                                        <span class="menu-icon">üîó</span>
                                        <span class="menu-text">Export as JSON</span>
                                    </button>
                                    <button class="menu-item" onclick="window.exportEncounterPDF(); closeEncounterMenu();">
                                        <span class="menu-icon">üìã</span>
                                        <span class="menu-text">Export as PDF</span>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <button onclick="generateEncounter()"><img src="assets/img/d20.png" alt="dice" class="dice-icon"> Generate Encounter</button>
                </div>

                <div class="encounter-display" id="encounterDisplay">
                    <div id="encounterContent"></div>
                </div>

                <!-- Room Display -->
                <div class="room-display" id="roomDisplay" style="display: none;">
                    <button onclick="returnToEncounter()" class="btn-danger btn-medium">
                        ‚Üê Back to Encounter
                    </button>
                    <div id="roomContent"></div>
                </div>
            </div>

            <!-- Location Detail Panel (Sticky) -->
            <div class="location-detail-panel" id="locationDetailPanel">
                <div class="close-btn" onclick="hideLocationDetail()">√ó</div>
                <div id="locationDetailContent"></div>
            </div>

            <!-- NPC Detail Panel (Sticky) -->
            <div class="location-detail-panel" id="npcDetailPanel">
                <div class="close-btn" onclick="hideNPCDetail()">√ó</div>
                <div id="npcDetailContent"></div>
            </div>

            <!-- NPC Hover Tooltip -->
            <div class="npc-tooltip" id="npcTooltip"></div>

            <!-- Quick Nav (Left Side Panel) -->
            <div class="flow-navigator-toggle" id="flowNavigatorToggle" onclick="toggleFlowNavigator()">
                ‚ñ∂
            </div>
            <div class="flow-navigator" id="flowNavigator">
                <div class="flow-nav-header">ÔøΩ Quick Nav</div>
                <div id="flowNavigatorContent"></div>
            </div>

            <!-- NPC Generator Page -->
            <div id="npcPage" class="page-content" style="display: none;">
                <div class="controls" style="max-width: 1000px; margin: 0 auto 40px auto;">
                    <h2 style="margin-bottom: 10px; color: var(--text-primary);">‚ö¨ NPC Generator</h2>
                    <p style="color: var(--text-secondary); margin-bottom: 20px; font-size: 0.95em;">
                        Choose specific traits or leave as "Random" for a surprise character!
                    </p>
                    
                    <!-- First Row: Species, Profession, Alignment -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                        <div class="control-group">
                            <label for="npcSpecies">Species:</label>
                        <select id="npcSpecies">
                            <option value="random">Random</option>
                        </select>
                        </div>

                        <div class="control-group">
                            <label for="npcProfession">Profession:</label>
                        <select id="npcProfession">
                            <option value="random">Random</option>
                        </select>
                        </div>

                        <div class="control-group">
                            <label for="npcAlignment">Alignment:</label>
                        <select id="npcAlignment">
                            <option value="random">Random</option>
                        </select>
                        </div>
                    </div>

                    <!-- Second Row: Personality -->
                    <div class="control-group" style="margin-bottom: 15px;">
                        <label for="npcPersonality">Personality:</label>
                        <select id="npcPersonality">
                            <option value="random">Random</option>
                        </select>
                    </div>

                    <button onclick="generateNPC()">‚ö° Generate NPC</button>
                </div>

                <div class="encounter-display" id="npcDisplay">
                    <div class="encounter-section">
                        <h2><img src="assets/img/d20.png" alt="dice" class="dice-icon"> Your NPC Will Appear Here</h2>
                        <p class="description">Click "Generate NPC" to create a diverse and interesting character for your campaign!</p>
                    </div>
                </div>
            </div>

            <!-- Search Page -->
            <div id="searchPage" class="page-content" style="display: none;">
                <div class="search-controls">
                    <div class="search-bar">
                        <input type="text" id="searchInput" placeholder="Search encounters and locations (e.g., 'tomb', 'ship', 'forest')..." />
                    </div>

                    <div class="filter-section">
                        <div class="filter-dropdowns">
                            <div class="filter-group">
                                <label for="envFilter">Environment</label>
                                <select id="envFilter" onchange="onEnvironmentChange()">
                                    <option value="">All Environments</option>
                                </select>
                            </div>
                            <div class="filter-group">
                                <label for="typeFilter">Type</label>
                                <select id="typeFilter" onchange="onFilterChange()">
                                    <option value="">All Types</option>
                                    <option value="encounter">Encounters</option>
                                    <option value="location">Locations</option>
                                </select>
                            </div>
                            <div class="filter-group">
                                <label for="locationTypeFilter">Location Type</label>
                                <select id="locationTypeFilter" onchange="onFilterChange()">
                                    <option value="">All Location Types</option>
                                </select>
                            </div>
                            <div class="filter-group">
                                <label for="settingFilter">Setting</label>
                                <select id="settingFilter" onchange="onFilterChange()">
                                    <option value="">All Settings</option>
                                </select>
                            </div>
                            <div class="filter-group">
                                <label for="planeFilter">Plane</label>
                                <select id="planeFilter" onchange="onFilterChange()">
                                    <option value="">All Planes</option>
                                </select>
                            </div>
                        </div>
                        <div class="filter-actions">
                            <button onclick="clearFilters()" class="btn-small">Clear All Filters</button>
                            <button onclick="performSearch()" class="btn-small">Search</button>
                        </div>
                    </div>
                </div>

                <div class="search-results" id="searchResults">
                    <p style="text-align: center; color: var(--text-secondary); padding: 40px;">Enter a search term or select tags to find encounters and locations</p>
                </div>
            </div>

            <!-- Settings Page -->
            <div id="settingsPage" class="page-content" style="display: none;">
                <div class="controls">
                    <h2 style="margin-bottom: 30px; color: var(--text-primary); font-size: 2em;">‚öôÔ∏è Settings</h2>
                    
                    <div class="settings-section">
                        <h2>Appearance</h2>
                        
                        <div class="setting-item">
                            <div class="setting-info">
                                <h3>Dark Mode</h3>
                                <p>Toggle between light and dark theme</p>
                            </div>
                            <div class="theme-switch" id="themeSwitch" onclick="toggleTheme()">
                                <div class="theme-switch-slider">
                                    <span class="theme-icon">üåô</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="settings-section">
                        <h2>Location Details Display</h2>
                        
                        <div class="setting-item">
                            <div class="setting-info">
                                <h3>Progressive Reveal</h3>
                                <p>When enabled, location details are revealed progressively (Primary ‚Üí Secondary ‚Üí Hidden). When disabled, all information is shown at once.</p>
                            </div>
                            <div class="theme-switch" id="progressiveRevealSwitch" onclick="toggleProgressiveReveal()">
                                <div class="theme-switch-slider">
                                    <span class="theme-icon">üîç</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="settings-section">
                        <h2>About</h2>
                        <p style="color: var(--text-secondary); line-height: 1.8;">
                            <strong style="color: var(--text-primary);">LoreWeaver</strong> is a D&D exploration encounter generator designed to help Dungeon Masters create engaging and dynamic encounters across various environments.
                        </p>
                        <p style="color: var(--text-secondary); margin-top: 16px; line-height: 1.8;">
                            Generate random encounters and locations, or search through the library to find exactly what you need for your campaign.
                        </p>
                    </div>
                </div>
            </div>

            <!-- Preview Modal -->
            <div id="previewModal" class="preview-modal">
                <div class="preview-content">
                    <button class="preview-close" onclick="closePreview()">‚úï</button>
                    <div id="previewBody"></div>
                </div>
            </div>

            <!-- Saved Encounters Modal -->
            <div id="savedEncountersModal" class="preview-modal">
                <div class="preview-content">
                    <button class="preview-close" onclick="document.getElementById('savedEncountersModal').style.display='none'">‚úï</button>
                    <h2 style="margin-bottom: 20px;">üìö Saved Encounters</h2>
                    <div id="savedEncountersList"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- JavaScript Modules -->
    <script type="module">
        // Import all modules - they will self-initialize and expose to window
        import './assets/js/data-loader.js';
        import { setRandomFunction, createSeededRandom, hashStringToSeed, random } from './assets/js/utils.js';
        import './assets/js/storage.js';
        import './assets/js/app.js';
        import { 
            exportEncounterMarkdown, 
            exportEncounterText, 
            exportEncounterPDF, 
            exportEncounterJSON,
            exportEncounter,
            getAvailableFormats 
        } from './assets/js/export.js';
        import './assets/js/core.js';
        import './assets/js/ui.js';
        
        // Expose export functions globally
        window.exportEncounterMarkdown = exportEncounterMarkdown;
        window.exportEncounterText = exportEncounterText;
        window.exportEncounterPDF = exportEncounterPDF;
        window.exportEncounterJSON = exportEncounterJSON;
        window.exportEncounter = exportEncounter;
        window.getAvailableFormats = getAvailableFormats;
        
        // Note: initApp is called automatically by app.js on DOMContentLoaded
    </script>

    <script>
        // ============================================================================
        // COMPLEX RENDERING FUNCTIONS (Temporarily inline until further refactoring)
        // ============================================================================

        // Global state variables (exposed to window for export functions)
        window.selectedEnvironment = null;
        window.activeFilters = { env: [], location: [], setting: [] };
        window.encounterTemplate = null;
        window.currentEncounterLocations = [];
        window.currentEncounterNPCs = [];
        window.currentEncounterSkillChecks = [];
        window.currentEncounterTraps = [];
        window.currentEncounterHazards = [];
        window.currentEncounterEnvironmentalEffects = [];
        window.currentEncounterFlow = [];
        window.currentRoomKey = null;

        // ============================================================================
        // ENVIRONMENT SELECTION
        // ============================================================================
        document.addEventListener('DOMContentLoaded', function() {
            // Set default environment from dropdown
            const envSelect = document.getElementById('environmentSelect');
            if (envSelect) {
                window.selectedEnvironment = envSelect.value;
            }
        });

        // ============================================================================
        // MAIN ENCOUNTER GENERATION
        // ============================================================================
        async function generateEncounter() {
            if (!window.dataLoaded) {
                alert('Data is still loading. Please wait a moment and try again.');
                return;
            }

            if (!window.selectedEnvironment) {
                alert('Please select an environment first!');
                return;
            }

            try {
                const partyLevel = parseInt(document.getElementById('partyLevel').value);
                const numLocations = parseInt(document.getElementById('numLocations').value);
                const seedInput = document.getElementById('encounterSeed').value.trim();

                // Handle seed
                let seed;
                if (seedInput) {
                    // Use provided seed
                    seed = window.hashStringToSeed(seedInput);
                    const seededRandom = window.createSeededRandom(seed);
                    window.setRandomFunction(seededRandom);
                    window.currentSeed = seedInput;
                } else {
                    // Generate random seed
                    window.currentSeed = Date.now().toString(36) + Math.random().toString(36).substr(2);
                    document.getElementById('encounterSeed').value = window.currentSeed;
                    seed = window.hashStringToSeed(window.currentSeed);
                    const seededRandom = window.createSeededRandom(seed);
                    window.setRandomFunction(seededRandom);
                }

                // Select encounter template - use preselected if available
                if (window.preselectedEncounter && window.preselectedEncounter.template) {
                    console.log('‚ú® Using preselected encounter:', window.preselectedEncounter.template.title);
                    window.encounterTemplate = window.preselectedEncounter.template;
                    window.selectedEnvironment = window.preselectedEncounter.environment;
                    // Clear the preselected encounter after use
                    window.preselectedEncounter = null;
                    // Remove the banner if it exists
                    const banner = document.getElementById('encounterSelectedBanner');
                    if (banner) banner.remove();
                } else {
                    window.encounterTemplate = window.selectEncounterTemplate(window.selectedEnvironment);
                }
                
                // Select content using smart selection from core.js
                window.currentEncounterSkillChecks = window.selectSkillChecks(window.encounterTemplate.tags, [], [], Math.floor(window.random() * 2) + 3);
                window.currentEncounterTraps = window.selectTraps(window.encounterTemplate.tags, Math.floor(window.random() * 3) + 2); // 2-4 traps
                window.currentEncounterHazards = window.selectHazards(window.selectedEnvironment, window.encounterTemplate.tags, Math.floor(window.random() * 3) + 2); // 2-4 hazards
                window.currentEncounterEnvironmentalEffects = window.selectEnvironmentalEffects(window.selectedEnvironment, window.encounterTemplate.tags, Math.floor(window.random() * 2) + 1); // 1-2 effects
                
                // Use custom locations if encounter specifies them, otherwise generate random locations
                if (window.encounterTemplate.customLocations && window.encounterTemplate.customLocations.length > 0) {
                    console.log('üìç Using custom locations for encounter:', window.encounterTemplate.customLocations);
                    // Respect the numLocations dropdown even with custom locations
                    const limitedCustomLocations = window.encounterTemplate.customLocations.slice(0, numLocations);
                    window.currentEncounterLocations = window.selectLocationsForEncounter(
                        window.encounterTemplate.tags, 
                        window.selectedEnvironment, 
                        null, 
                        limitedCustomLocations
                    );
                } else {
                    window.currentEncounterLocations = window.selectLocationsForEncounter(
                        window.encounterTemplate.tags, 
                        window.selectedEnvironment, 
                        numLocations
                    );
                }
                
                window.currentEncounterNPCs = window.selectNPCsForEncounter(window.encounterTemplate.tags, Math.floor(window.random() * 3) + 2);

                // Generate encounter flow
                window.currentEncounterFlow = generateEncounterFlow();

                // Display encounter
                displayEncounter();
            } catch (error) {
                console.error('‚ùå Error during encounter generation:', error);
                alert('Error generating encounter: ' + error.message);
            }
        }

        function displayEncounter() {
            const container = document.getElementById('encounterContent');
            const partyLevel = parseInt(document.getElementById('partyLevel').value);
            
            let html = `
                <div class="encounter-section">
                    <div class="section-header">
                        <h2 onclick="toggleSection(event)">üìú ${window.encounterTemplate.title} <span class="section-toggle">‚ñº</span></h2>
                    </div>
                    <div class="section-content">
                        <p class="description">${window.buildEncounterDescription(window.selectedEnvironment, window.encounterTemplate.title, window.encounterTemplate.descriptions || window.encounterTemplate.description)}</p>
                    </div>
                </div>`;

            // Encounter Flow
            // Count actual locations (exclude Resolution step)
            const actualLocationCount = window.currentEncounterLocations.length;
            html += `
                <div class="encounter-section">
                    <h2 onclick="toggleSection(event)">üó∫Ô∏è Encounter Flow <span class="section-toggle">‚ñº</span></h2>
                    <div class="section-content">
                        <p class="description">This encounter unfolds across ${actualLocationCount} key location${actualLocationCount !== 1 ? 's' : ''}, each with unique challenges and discoveries.</p>
                        <button class="btn-primary" onclick="addNewLocation()" style="margin-bottom: 15px;">‚ûï Add Another Location</button>
                        <div id="flowStepsContainer">`;
            
            window.currentEncounterFlow.forEach((step, index) => {
                const isResolution = step.title === "Resolution";
                const isBranching = step.title === "Branching Paths & Optional Areas";
                const isNormalStep = !isResolution && !isBranching;
                const isLastStep = index === window.currentEncounterFlow.length - 1;
                
                if (isBranching) {
                    // Branching paths styling
                    html += `
                        <div id="flow-step-${step.step}" class="flow-step" style="background: linear-gradient(135deg, rgba(155, 89, 182, 0.15), rgba(142, 68, 173, 0.1)); border-left: 4px solid #9b59b6; padding: 20px; margin: 20px 0; border-radius: 8px; position: relative;">
                            <div style="display: flex; align-items: center; margin-bottom: 15px;">
                                <div style="background: #9b59b6; color: white; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; margin-right: 15px; flex-shrink: 0;">
                                    ${step.step}
                                </div>
                                <h3 style="margin: 0; color: #9b59b6;">üîÄ ${step.title}</h3>
                            </div>
                            <p class="description" style="margin: 15px 0; font-style: italic;">${step.description}</p>
                        </div>`;
                } else if (isResolution) {
                    // Resolution styling
                    html += `
                        <div id="flow-step-${step.step}" class="flow-step" style="background: linear-gradient(135deg, rgba(39, 174, 96, 0.15), rgba(46, 204, 113, 0.1)); border-left: 4px solid #27ae60; padding: 20px; margin: 20px 0; border-radius: 8px; position: relative;">
                            <div style="display: flex; align-items: center; margin-bottom: 15px;">
                                <div style="background: #27ae60; color: white; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; margin-right: 15px; flex-shrink: 0;">
                                    ‚úì
                                </div>
                                <h3 style="margin: 0; color: #27ae60;">${step.title}</h3>
                            </div>
                            <p class="description" style="margin: 15px 0; font-style: italic;">${step.description}</p>
                            
                            ${step.customResolutions && step.customResolutions.length > 0 ? `
                                <div style="margin-top: 20px;">
                                    <h4 style="color: #27ae60; margin-bottom: 15px;">Possible Resolutions:</h4>
                                    ${step.customResolutions.map((resolution, resIndex) => `
                                        <div style="background: rgba(39, 174, 96, 0.08); border-left: 3px solid #27ae60; border-radius: 6px; padding: 15px; margin-bottom: 15px;">
                                            <h5 style="margin: 0 0 10px 0; color: #27ae60; font-size: 1.05em;">
                                                ${resIndex + 1}. ${resolution.title}
                                            </h5>
                                            <p style="margin: 8px 0; font-size: 0.95em; line-height: 1.5;">
                                                ${resolution.description}
                                            </p>
                                            <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(39, 174, 96, 0.2);">
                                                <div style="margin-bottom: 6px;">
                                                    <strong style="color: var(--accent-blue); font-size: 0.9em;">‚öôÔ∏è Requirements:</strong>
                                                    <span style="font-size: 0.9em; color: var(--text-secondary);"> ${resolution.requirements}</span>
                                                </div>
                                                <div>
                                                    <strong style="color: #f39c12; font-size: 0.9em;">Rewards:</strong>
                                                    <span style="font-size: 0.9em; color: var(--text-secondary);"> ${resolution.rewards}</span>
                                                </div>
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                            ` : ''}
                            
                            ${step.dmTips && step.dmTips.length > 0 ? `
                                <div style="background: rgba(39, 174, 96, 0.08); border-radius: 6px; padding: 12px; margin-top: 15px;">
                                    <strong style="color: var(--accent-blue);">üí° DM Tips:</strong>
                                    <ul style="margin: 8px 0 0 0; padding-left: 20px; font-size: 0.95em;">
                                        ${step.dmTips.map(tip => `<li>${tip}</li>`).join('')}
                                    </ul>
                                </div>
                            ` : ''}
                        </div>`;
                } else {
                    // Normal step styling
                    html += `
                        <div id="flow-step-${step.step}" class="flow-step location-step-hover" style="background: rgba(52, 152, 219, 0.1); border-left: 4px solid var(--accent-blue); padding: 20px; margin: 20px 0; border-radius: 8px; position: relative;">
                            <div class="location-actions" style="position: absolute; top: 20px; right: 20px; display: flex; gap: 8px; opacity: 0; transition: opacity 0.2s;">
                                ${step.locationIndex !== undefined && step.locationIndex > 0 ? `<button onclick="moveLocationUp(${step.locationIndex})" 
                                        style="background: gainsboro; border: none; color: var(--accent-blue); padding: 4px 6px; cursor: pointer; font-size: 1em; line-height: 1; width: auto; min-width: 0; border-radius: 4px;"
                                        title="Move location up">‚Üë</button>` : ''}
                                ${step.locationIndex !== undefined && step.locationIndex < window.currentEncounterLocations.length - 1 ? `<button onclick="moveLocationDown(${step.locationIndex})" 
                                        style="background: gainsboro; border: none; color: var(--accent-blue); padding: 4px 6px; cursor: pointer; font-size: 1em; line-height: 1; width: auto; min-width: 0; border-radius: 4px;"
                                        title="Move location down">‚Üì</button>` : ''}
                                ${step.locationIndex !== undefined ? `<button onclick="regenerateFlowLocation(${step.locationIndex})" 
                                        style="background: gainsboro; border: none; color: var(--accent-blue); padding: 4px 6px; cursor: pointer; font-size: 1em; line-height: 1; width: auto; min-width: 0; border-radius: 4px;"
                                        title="Regenerate this location">‚ü≥</button>` : ''}
                                ${step.locationIndex !== undefined && window.currentEncounterLocations.length > 1 ? `<button onclick="removeLocation(${step.locationIndex})" 
                                        style="background: gainsboro; border: none; color: #e74c3c; padding: 4px 6px; cursor: pointer; font-size: 1em; line-height: 1; width: auto; min-width: 0; border-radius: 4px;"
                                        title="Remove this location">‚úï</button>` : ''}
                            </div>
                            <div style="display: flex; align-items: center; margin-bottom: 15px;">
                                <div style="background: var(--accent-blue); color: white; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; margin-right: 15px; flex-shrink: 0;">
                                    ${step.step}
                                </div>
                                <h3 style="margin: 0; color: var(--accent-blue); flex-grow: 1; padding-right: 120px;">${step.title}</h3>
                            </div>
                            
                            <div style="background: rgba(52, 152, 219, 0.15); border-radius: 6px; padding: 12px; margin-bottom: 15px;">
                                <strong style="color: var(--accent-blue);">üìç Location: <span class="location-link" onclick="window.showLocationDetail('${step.location?.key || step.location}', 'primary')">${step.location?.name || window.formatLocationName(step.location?.key) || 'Unknown Location'}</span></strong>
                            </div>
                            
                            <p class="description" style="margin: 15px 0; font-style: italic;">${step.description}</p>
                            
                            ${step.connections && step.connections.length > 0 ? `
                                <div style="margin: 15px 0;">
                                    <strong style="color: var(--accent-blue);">üîó How the party arrives here:</strong>
                                    <ul style="margin: 8px 0 0 0; padding-left: 20px; font-size: 0.95em;">
                                        ${step.connections.map(conn => `<li>${conn}</li>`).join('')}
                                    </ul>
                                </div>
                            ` : ''}
                            
                            <div style="background: rgba(52, 152, 219, 0.08); border-radius: 6px; padding: 12px; margin-top: 15px;">
                                <strong style="color: var(--accent-blue);">üí° DM Tips:</strong>
                                <ul style="margin: 8px 0 0 0; padding-left: 20px; font-size: 0.95em;">
                                    ${step.dmTips && step.dmTips.length > 0 ? step.dmTips.map(tip => `<li>${tip}</li>`).join('') : '<li>No specific tips for this step</li>'}
                                </ul>
                            </div>
                        </div>`;
                }
                
                // Add connector arrow between steps (except after last step)
                if (!isLastStep) {
                    html += `
                        <div style="text-align: center; margin: 10px 0; color: var(--accent-blue); font-size: 24px;">
                            ‚Üì
                        </div>`;
                }
            });

            html += `
                        </div>
                    </div>
                </div>`;

            // NPCs
            console.log('displayEncounter - currentEncounterNPCs:', window.currentEncounterNPCs);
            console.log('displayEncounter - NPC count:', window.currentEncounterNPCs?.length);
            if (window.currentEncounterNPCs && window.currentEncounterNPCs.length > 0) {
                html += `
                    <div class="encounter-section">
                        <h2 onclick="toggleSection(event)">üë• NPCs (${window.currentEncounterNPCs.length}) <span class="section-toggle">‚ñº</span></h2>
                        <div class="section-content" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px;">`;
                
                window.currentEncounterNPCs.forEach((npc, idx) => {
                    html += `
                        <div class="card npc-card npc-card-hover" 
                             onmouseenter="window.showNPCTooltip(event, ${idx})" 
                             onmouseleave="window.hideNPCTooltip()"
                             onclick="window.showNPCDetail(${idx})"
                             style="position: relative; margin: 0; padding: 12px 20px;">
                            <h3 style="display: flex; align-items: center; justify-content: space-between; margin-top: 0;">
                                <span>${npc.name}</span>
                                <button class="hover-action-btn" onclick="removeNPC(${idx}); event.stopPropagation();" 
                                        style="background: gainsboro; border: none; color: #e74c3c; padding: 4px 6px; cursor: pointer; font-size: 0.9em; line-height: 1; width: auto; min-width: 0; opacity: 0; transition: opacity 0.2s; border-radius: 4px;"
                                        title="Remove this NPC">‚úï</button>
                            </h3>
                            <p><strong>Species:</strong> ${npc.species} | <strong>Profession:</strong> ${npc.profession?.name || npc.profession}</p>
                            <p class="description">${npc.appearance?.description || npc.appearance}</p>
                            <button onclick="window.showNPCDetail(${idx}); event.stopPropagation();" class="btn-small btn-primary">
                                üìñ Full Details
                            </button>
                        </div>`;
                });
                
                html += `
                        </div>
                    </div>`;
            }

            container.innerHTML = html;
            
            // Make sure the encounter display is visible
            const encounterDisplay = document.getElementById('encounterDisplay');
            if (encounterDisplay) {
                encounterDisplay.classList.add('active');
            }
            
            // Populate flow navigator
            window.populateFlowNavigator(window.currentEncounterFlow);
        }

        // Expose displayEncounter to window for cross-module access
        window.displayEncounter = displayEncounter;

        // ============================================================================
        // ENCOUNTER FLOW GENERATION
        // ============================================================================
        function generateEncounterFlow() {
            if (window.currentEncounterLocations.length === 0) return [];
            
            // Helper function to wrap NPC name with interactive elements
            function wrapNPCName(npc, index) {
                return `<span class="npc-link" 
                             onclick="window.showNPCDetail(${index})" 
                             onmouseenter="window.showNPCTooltip(event, ${index})"
                             onmouseleave="window.hideNPCTooltip()">${npc.name}</span>`;
            }
            
            // Helper function to wrap location-specific NPC with interactive elements
            function wrapLocationNPCName(npc) {
                const npcDataJson = JSON.stringify(npc).replace(/"/g, '&quot;');
                return `<span class="npc-link" 
                             onclick="window.showNPCDetailFromObject(this.getAttribute('data-npc'))" 
                             data-npc="${npcDataJson}">${npc.name}</span>`;
            }
            
            const flowSteps = [];
            
            // Step 1: Initial encounter setup
            const step1Tips = [
                "Set the atmosphere with sensory details from the location description",
                "Introduce environmental effects or hazards to establish tension",
                window.currentEncounterNPCs.length > 0 ? `Consider having ${wrapNPCName(window.currentEncounterNPCs[0], 0)} (${window.currentEncounterNPCs[0].profession?.name || window.currentEncounterNPCs[0].profession}) present here` : "Consider adding ambient sounds or NPC activity"
            ];
            
            // Add location-specific NPCs to DM Tips
            if (window.currentEncounterLocations[0].npcs && window.currentEncounterLocations[0].npcs.length > 0) {
                window.currentEncounterLocations[0].npcs.forEach(npc => {
                    step1Tips.push(`${wrapLocationNPCName(npc)} (${npc.profession?.name || npc.profession}) is present at this location`);
                });
            }
            
            flowSteps.push({
                step: 1,
                locationIndex: 0,
                title: "Initial Discovery",
                location: window.currentEncounterLocations[0],
                description: `The party first encounters ${window.encounterTemplate.title.toLowerCase()}. They arrive at ${window.currentEncounterLocations[0].name}, where the situation begins to unfold.`,
                dmTips: step1Tips
            });
            
            // Step 2: Investigation/Complication (if there's a second location)
            if (window.currentEncounterLocations.length > 1) {
                const step2Tips = [
                    `Primary features from ${window.currentEncounterLocations[0].name} can provide hints or connections to this location`,
                    "Introduce skill challenges or traps as the party moves between locations",
                    window.currentEncounterNPCs.length > 1 ? `${wrapNPCName(window.currentEncounterNPCs[1], 1)} might provide information, create obstacles, or offer assistance` : "Add tension through environmental effects"
                ];
                
                // Add location-specific NPCs to DM Tips
                if (window.currentEncounterLocations[1].npcs && window.currentEncounterLocations[1].npcs.length > 0) {
                    window.currentEncounterLocations[1].npcs.forEach(npc => {
                        step2Tips.push(`${wrapLocationNPCName(npc)} (${npc.profession?.name || npc.profession}) is present at this location`);
                    });
                }
                
                flowSteps.push({
                    step: 2,
                    locationIndex: 1,
                    title: "Investigation & Complications",
                    location: window.currentEncounterLocations[1],
                    description: `Clues, encounters, or circumstances lead the party to ${window.currentEncounterLocations[1].name}. The situation deepens as they uncover more details.`,
                    dmTips: step2Tips,
                    connections: [
                        `Evidence at ${window.currentEncounterLocations[0].name} points to activity here`,
                        `NPCs or witnesses mention this location`,
                        `A discovered map, key, or clue leads directly here`
                    ]
                });
            }
            
            // Step 3: Escalation (if there's a third location)
            if (window.currentEncounterLocations.length > 2) {
                const step3Tips = [
                    "This is where major conflict, revelations, or challenges should occur",
                    "Combine multiple hazards or environmental effects for maximum drama",
                    window.currentEncounterNPCs.length > 2 ? `${wrapNPCName(window.currentEncounterNPCs[2], 2)}'s secret or motivations might be revealed here` : "Consider adding a time-pressure element"
                ];
                
                // Add location-specific NPCs to DM Tips
                if (window.currentEncounterLocations[2].npcs && window.currentEncounterLocations[2].npcs.length > 0) {
                    window.currentEncounterLocations[2].npcs.forEach(npc => {
                        step3Tips.push(`${wrapLocationNPCName(npc)} (${npc.profession?.name || npc.profession}) is present at this location`);
                    });
                }
                
                flowSteps.push({
                    step: 3,
                    locationIndex: 2,
                    title: "Escalation Point",
                    location: window.currentEncounterLocations[2],
                    description: `The encounter intensifies at ${window.currentEncounterLocations[2].name}. Stakes are raised and the party must make crucial decisions.`,
                    dmTips: step3Tips,
                    connections: [
                        `Chase, pursuit, or urgency drives the party from ${window.currentEncounterLocations[1].name}`,
                        `A discovered tertiary object reveals the true nature of the situation`,
                        `Environmental hazards force movement to this location`
                    ]
                });
            }
            
            // Step 4+: Additional locations become individual optional steps
            if (window.currentEncounterLocations.length > 3) {
                const remainingLocations = window.currentEncounterLocations.slice(3);
                remainingLocations.forEach((loc, i) => {
                    const actualIndex = 3 + i;
                    const stepNumber = 4 + i;
                    
                    const additionalTips = [
                        "This location can be explored at any point during the encounter",
                        "Use this as a reward for good investigation or clever thinking",
                        "Can provide alternative solutions, shortcuts, or additional complications"
                    ];
                    
                    // Add location-specific NPCs to DM Tips
                    if (loc.npcs && loc.npcs.length > 0) {
                        loc.npcs.forEach(npc => {
                            additionalTips.push(`${wrapLocationNPCName(npc)} (${npc.profession?.name || npc.profession}) is present at this location`);
                        });
                    }
                    
                    flowSteps.push({
                        step: stepNumber,
                        locationIndex: actualIndex,
                        title: `Optional Location: ${loc.name}`,
                        location: loc,
                        description: `The party may discover ${loc.name} through investigation, following leads, or by choice. This location is optional and can be explored at any time.`,
                        dmTips: additionalTips,
                        connections: [
                            "Party splits up to cover more ground",
                            "Following a specific NPC or lead",
                            "Seeking additional resources or information",
                            "Avoiding danger in the main path"
                        ]
                    });
                });
            }
            
            // Final step: Resolution
            const finalLocation = currentEncounterLocations.length > 2 ? currentEncounterLocations[2] : currentEncounterLocations[currentEncounterLocations.length - 1];
            
            // Check if encounter has custom resolutions
            const hasCustomResolutions = encounterTemplate && encounterTemplate.resolutions && encounterTemplate.resolutions.length > 0;
            
            if (hasCustomResolutions) {
                // Use custom resolutions from encounter template
                flowSteps.push({
                    step: flowSteps.length + 1,
                    title: "Resolution",
                    location: finalLocation,
                    description: `The encounter concludes with multiple possible outcomes based on the party's investigation and choices.`,
                    customResolutions: encounterTemplate.resolutions,
                    dmTips: [
                        "Review the party's investigation - which locations did they visit?",
                        "Which clues and evidence did they discover?",
                        "How thoroughly did they investigate each location?",
                        "Based on their choices, select the most appropriate resolution below"
                    ]
                });
            } else {
                // Use generic resolution
                flowSteps.push({
                    step: flowSteps.length + 1,
                    title: "Resolution",
                    location: finalLocation,
                    description: `The encounter concludes, typically at ${finalLocation.name} or wherever the party's investigation leads them.`,
                    dmTips: [
                        "Tie up loose threads and reveal the outcome of the party's choices",
                        "Tertiary discoveries here can provide significant rewards or plot hooks",
                        "NPCs react to how the party handled the situation",
                        "Set up future adventures or consequences based on the resolution"
                    ]
                });
            }
            
            return flowSteps;
        }

        // Expose generateEncounterFlow to window for cross-module access
        window.generateEncounterFlow = generateEncounterFlow;

        // ============================================================================
        // FLOW MANIPULATION FUNCTIONS
        // ============================================================================
        function addNewLocation() {
            console.log('addNewLocation - Before:', window.currentEncounterLocations.length);
            const newLoc = window.selectLocationsForEncounter(window.encounterTemplate.tags, window.selectedEnvironment, 1)[0];
            window.currentEncounterLocations.push(newLoc);
            console.log('addNewLocation - After:', window.currentEncounterLocations.length);
            console.log('addNewLocation - New location:', newLoc.name);
            window.currentEncounterFlow = generateEncounterFlow();
            console.log('addNewLocation - Flow steps:', window.currentEncounterFlow.length);
            displayEncounter();
        }

        function removeLocation(index) {
            if (window.currentEncounterLocations.length <= 1) {
                alert('You must have at least one location!');
                return;
            }
            
            const locationToRemove = window.currentEncounterLocations[index];
            
            // If this location had NPCs assigned to it, they stay in the general NPC pool
            // but we remove them from the location.npcs array (which will be deleted anyway)
            // No action needed as we're removing the entire location
            
            // Remove the location from the array
            window.currentEncounterLocations.splice(index, 1);
            
            // Regenerate flow and display
            window.currentEncounterFlow = generateEncounterFlow();
            displayEncounter();
        }

        function moveLocationUp(index) {
            if (index === 0) return;
            [window.currentEncounterLocations[index], window.currentEncounterLocations[index - 1]] = 
            [window.currentEncounterLocations[index - 1], window.currentEncounterLocations[index]];
            window.currentEncounterFlow = generateEncounterFlow();
            displayEncounter();
        }

        function moveLocationDown(index) {
            if (index === window.currentEncounterLocations.length - 1) return;
            [window.currentEncounterLocations[index], window.currentEncounterLocations[index + 1]] = 
            [window.currentEncounterLocations[index + 1], window.currentEncounterLocations[index]];
            window.currentEncounterFlow = generateEncounterFlow();
            displayEncounter();
        }

        function regenerateFlowLocation(index) {
            const newLoc = window.selectLocationsForEncounter(window.encounterTemplate.tags, window.selectedEnvironment, 1)[0];
            window.currentEncounterLocations[index] = newLoc;
            window.currentEncounterFlow = generateEncounterFlow();
            displayEncounter();
        }

        function regenerateNPC(index) {
            const newNPC = window.selectNPCsForEncounter(window.encounterTemplate.tags, 1)[0];
            window.currentEncounterNPCs[index] = newNPC;
            window.currentEncounterFlow = generateEncounterFlow();
            displayEncounter();
        }

        function removeNPC(index) {
            const npcToRemove = window.currentEncounterNPCs[index];
            
            // Remove the NPC from the main array
            window.currentEncounterNPCs.splice(index, 1);
            
            // Remove this NPC from any location-specific NPC arrays
            window.currentEncounterLocations.forEach(location => {
                if (location.npcs && location.npcs.length > 0) {
                    location.npcs = location.npcs.filter(npc => 
                        npc.name !== npcToRemove.name || 
                        npc.species !== npcToRemove.species ||
                        (npc.profession?.name || npc.profession) !== (npcToRemove.profession?.name || npcToRemove.profession)
                    );
                }
            });
            
            // Regenerate flow and display
            window.currentEncounterFlow = generateEncounterFlow();
            displayEncounter();
        }

        // ============================================================================
        // REBUILD ENCOUNTER FROM SAVED DATA
        // ============================================================================
        function rebuildEncounterDisplay(savedData) {
            window.encounterTemplate = savedData.template;
            window.selectedEnvironment = savedData.environment;
            window.currentEncounterLocations = savedData.locations;
            window.currentEncounterNPCs = savedData.npcs;
            window.currentEncounterSkillChecks = savedData.skillChecks;
            window.currentEncounterTraps = savedData.traps;
            window.currentEncounterHazards = savedData.hazards;
            window.currentEncounterEnvironmentalEffects = savedData.environmentalEffects;
            window.currentEncounterFlow = savedData.flow;
            
            document.getElementById('partyLevel').value = savedData.partyLevel;
            
            const envTags = document.querySelectorAll('.environment-tags .tag');
            envTags.forEach(tag => {
                if (tag.getAttribute('data-env') === window.selectedEnvironment) {
                    tag.classList.add('active');
                } else {
                    tag.classList.remove('active');
                }
            });
            
            displayEncounter();
        }

        // Make rebuildEncounterDisplay available globally for storage.js
        window.rebuildEncounterDisplay = rebuildEncounterDisplay;

        // ============================================================================
        // ROOM EXPLORATION (Progressive Reveal)
        // ============================================================================
        function generateRoom(locationKey) {
            const location = (window.locationObjects?.[selectedEnvironment] || {})[locationKey];
            if (!location) return;
            
            currentRoomKey = locationKey;
            
            const encounterDisplay = document.getElementById('encounterDisplay');
            const roomDisplay = document.getElementById('roomDisplay');
            const roomContent = document.getElementById('roomContent');
            
            let html = `
                <div class="room-header">
                    <h2>üö™ Exploring: ${window.formatLocationName(locationKey)}</h2>
                    <p class="description">The party enters the room and begins to explore...</p>
                </div>
                
                <div class="room-objects">
                    <h3>üîç Objects in the Room:</h3>`;
            
            if (Array.isArray(location.primary) && location.primary.length > 0) {
                location.primary.forEach((objName, idx) => {
                    html += `
                        <div class="room-object-card">
                            <h4>${objName}</h4>
                            <button onclick="exploreObject('${locationKey}', 'primary', ${idx})" class="btn-primary">
                                üîé Examine
                            </button>
                        </div>`;
                });
            } else {
                html += `<p style="color: var(--text-secondary); padding: 20px;">The room appears empty at first glance...</p>`;
            }
            
            html += `
                </div>
                <div id="explorationResults"></div>`;
            
            roomContent.innerHTML = html;
            encounterDisplay.style.display = 'none';
            roomDisplay.style.display = 'block';
        }

        function exploreObject(locationKey, level, objectIndex) {
            const location = (window.locationObjects?.[selectedEnvironment] || {})[locationKey];
            const resultsDiv = document.getElementById('explorationResults');
            
            let html = `
                <div class="exploration-result">
                    <h3>üìñ Discovery: ${Array.isArray(location.primary) ? location.primary[objectIndex] : 'Object'}</h3>`;
            
            if (level === 'primary' && Array.isArray(location.primary) && location.primary[objectIndex] !== undefined) {
                const primaryDesc = location.primary[objectIndex];
                html += `<p class="description">${primaryDesc}</p>`;
                
                if (Array.isArray(location.secondary) && location.secondary[objectIndex] !== undefined) {
                    html += `
                        <button onclick="exploreObject('${locationKey}', 'secondary', ${objectIndex})" class="btn-primary" style="margin-top: 12px;">
                            üîç Investigate Further
                        </button>`;
                }
            } else if (level === 'secondary' && Array.isArray(location.secondary) && location.secondary[objectIndex] !== undefined) {
                const secondaryDesc = location.secondary[objectIndex];
                html += `<p class="description">${secondaryDesc}</p>`;
                
                if (Array.isArray(location.tertiary) && location.tertiary[objectIndex] !== undefined) {
                    html += `
                        <button onclick="exploreObject('${locationKey}', 'tertiary', ${objectIndex})" class="btn-primary" style="margin-top: 12px;">
                            üîé Search Thoroughly
                        </button>`;
                }
            } else if (level === 'tertiary' && Array.isArray(location.tertiary) && location.tertiary[objectIndex] !== undefined) {
                const tertiaryDesc = location.tertiary[objectIndex];
                html += `<p class="description">${tertiaryDesc}</p>`;
                html += `<p style="margin-top: 12px; color: var(--accent-blue);"><em>You've discovered everything about this object!</em></p>`;
            }
            
            html += `</div>`;
            resultsDiv.innerHTML = html;
        }

        function returnToEncounter() {
            document.getElementById('encounterDisplay').style.display = 'block';
            document.getElementById('roomDisplay').style.display = 'none';
            currentRoomKey = null;
        }

        // ============================================================================
        // SEARCH FUNCTIONALITY
        // ============================================================================
        function performSearch() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase().trim();
            const resultsDiv = document.getElementById('searchResults');
            
            if (searchTerm.length === 0 && activeFilters.env.length === 0 && activeFilters.location.length === 0 && activeFilters.setting.length === 0) {
                resultsDiv.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 40px;">Enter a search term or select tags to find encounters and locations</p>';
                return;
            }
            
            const results = [];
            
            // Search encounters
            Object.entries(window.encounterTitles).forEach(([env, encounters]) => {
                if (activeFilters.env.length > 0 && !activeFilters.env.includes(env)) return;
                
                encounters.forEach(encounter => {
                    const matchesSearch = searchTerm.length === 0 || 
                        encounter.title.toLowerCase().includes(searchTerm) ||
                        encounter.description.toString().toLowerCase().includes(searchTerm) ||
                        encounter.tags.some(tag => tag.toLowerCase().includes(searchTerm));
                    
                    const matchesTags = 
                        (activeFilters.env.length === 0 || activeFilters.env.includes(env)) &&
                        (activeFilters.setting.length === 0 || encounter.tags.some(tag => activeFilters.setting.includes(tag)));
                    
                    if (matchesSearch && matchesTags) {
                        results.push({
                            type: 'encounter',
                            environment: env,
                            title: encounter.title,
                            data: encounter
                        });
                    }
                });
            });
            
            // Search locations (iterate environments and their locations)
            Object.entries(window.locationObjects || {}).forEach(([env, envLocations]) => {
                Object.entries(envLocations || {}).forEach(([locKey, locData]) => {
                    const type = locKey;
                    const tags = locData.tags || [];

                    const matchesSearch = searchTerm.length === 0 ||
                        type.toLowerCase().includes(searchTerm) ||
                        tags.some(tag => tag.toLowerCase().includes(searchTerm));

                    const matchesTags =
                        (activeFilters.env.length === 0 || activeFilters.env.includes(env)) &&
                        (activeFilters.location.length === 0 || activeFilters.location.includes(type)) &&
                        (activeFilters.setting.length === 0 || tags.some(tag => activeFilters.setting.includes(tag)));

                    if (matchesSearch && matchesTags) {
                        results.push({
                            type: 'location',
                            environment: env,
                            title: window.formatLocationName ? window.formatLocationName(type) : type,
                            key: locKey,
                            data: locData
                        });
                    }
                });
            });
            
            displaySearchResults(results);
        }

        function displaySearchResults(results) {
            const resultsDiv = document.getElementById('searchResults');
            
            if (results.length === 0) {
                resultsDiv.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 40px;">No results found. Try different search terms or filters.</p>';
                return;
            }
            
            let html = `<h3 style="margin-bottom: 20px; color: var(--text-primary);">Found ${results.length} result${results.length === 1 ? '' : 's'}:</h3>`;
            
            results.forEach((result, idx) => {
                if (result.type === 'encounter') {
                    html += `
                        <div class="result-card">
                            <div class="result-header">
                                <h3>üìú ${result.title}</h3>
                                <span class="tag">${result.environment}</span>
                            </div>
                            <div class="result-tags">
                                ${result.data.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}
                            </div>
                            <div class="result-actions">
                                <button onclick="previewResult(${idx}, ${JSON.stringify(results).replace(/"/g, '&quot;')})" class="btn-small" style="background: gainsboro; color: var(--accent-blue);">
                                    ‚óâ Preview
                                </button>
                                <button onclick="openResult('encounter', '${result.environment}', '${result.title.replace(/'/g, "\\'")}')" class="btn-small btn-primary">
                                    ‚ö° Generate
                                </button>
                            </div>
                        </div>`;
                } else if (result.type === 'location') {
                    html += `
                        <div class="result-card">
                            <div class="result-header">
                                <h3>üìç ${result.title}</h3>
                            </div>
                            ${result.data.tags ? `<div class="result-tags">
                                ${result.data.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}
                            </div>` : ''}
                            <div class="result-actions">
                                <button onclick="window.showLocationDetail('${result.key}', 'all', null, '${result.environment}')" class="btn-small btn-primary">
                                    ‚Üí View Details
                                </button>
                            </div>
                        </div>`;
                }
            });
            
            resultsDiv.innerHTML = html;
        }

        function previewResult(index, results) {
            const result = results[index];
            const modal = document.getElementById('previewModal');
            const body = document.getElementById('previewBody');
            
            let html = `<h2>${result.title}</h2>`;
            
            if (result.type === 'encounter') {
                html += `
                    <div style="margin: 20px 0;">
                        <span class="tag">${result.environment}</span>
                        ${result.data.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}
                    </div>
                    <p class="description">${window.buildEncounterDescription(result.environment, result.title, result.data.descriptions || result.data.description)}</p>`;
            }
            
            body.innerHTML = html;
            modal.style.display = 'flex';
        }

        function closePreview() {
            document.getElementById('previewModal').style.display = 'none';
        }

        function openResult(type, environment, title) {
            if (type === 'encounter') {
                // Switch to generate page
                window.switchPage('generate');
                
                // Set environment
                selectedEnvironment = environment;
                const envSelect = document.getElementById('environmentSelect');
                if (envSelect) {
                    envSelect.value = environment;
                }
                
                // Find and use specific encounter
                const encounters = window.encounterTitles[environment];
                encounterTemplate = encounters.find(e => e.title === title);
                
                if (encounterTemplate) {
                    const partyLevel = parseInt(document.getElementById('partyLevel').value);
                    
                    // Generate a seed for this encounter
                    window.currentSeed = Date.now().toString(36) + Math.random().toString(36).substr(2);
                    document.getElementById('encounterSeed').value = window.currentSeed;
                    const seed = window.hashStringToSeed(window.currentSeed);
                    const seededRandom = window.createSeededRandom(seed);
                    window.setRandomFunction(seededRandom);
                    
                    currentEncounterSkillChecks = window.selectSkillChecks(encounterTemplate.tags, [], [], Math.floor(window.random() * 2) + 3);
                    currentEncounterTraps = window.selectTraps([], window.random() < 0.3 ? 0 : window.random() < 0.5 ? 1 : 2);
                    currentEncounterHazards = window.selectHazards(environment, [], window.random() < 0.6 ? 1 : 2);
                    currentEncounterEnvironmentalEffects = window.selectEnvironmentalEffects(environment, encounterTemplate.tags, window.random() < 0.4 ? 1 : 0);
                    
                    // Handle custom locations if they exist
                    if (encounterTemplate.customLocations && encounterTemplate.customLocations.length > 0) {
                        // Use custom locations for this encounter
                        currentEncounterLocations = window.selectLocationsForEncounter(
                            encounterTemplate.tags, 
                            environment, 
                            encounterTemplate.customLocations.length,
                            encounterTemplate.customLocations
                        );
                    } else {
                        // Use normal location selection
                        const numLocations = parseInt(document.getElementById('numLocations').value);
                        currentEncounterLocations = window.selectLocationsForEncounter(encounterTemplate.tags, environment, numLocations);
                    }
                    
                    currentEncounterNPCs = window.selectNPCsForEncounter(encounterTemplate.tags, Math.floor(window.random() * 3) + 2);
                    currentEncounterFlow = generateEncounterFlow();
                    
                    displayEncounter();
                }
            }
        }

        // Toggle filter
        function toggleFilter(element, type, value) {
            element.classList.toggle('active');

            const filterMap = {
                'environment': 'env',
                'locationType': 'location',
                'setting': 'setting'
            };

            const filterKey = filterMap[type] || type;
            const index = activeFilters[filterKey].indexOf(value);
            
            if (index > -1) {
                activeFilters[filterKey].splice(index, 1);
            } else {
                activeFilters[filterKey].push(value);
            }

            performSearch();
        }

        function clearFilters() {
            activeFilters = { env: [], location: [], setting: [] };
            document.querySelectorAll('.filter-tags .filter-tag').forEach(tag => {
                tag.classList.remove('active');
            });
            document.getElementById('searchInput').value = '';
            performSearch();
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.encounter-actions')) {
                window.closeEncounterMenu();
            }
        });

        // Make functions globally available for the modules and HTML onclick
        window.generateEncounter = generateEncounter;
        window.generateRoom = generateRoom;
        window.exploreObject = exploreObject;
        window.returnToEncounter = returnToEncounter;
        window.performSearch = performSearch;
        window.toggleFilter = toggleFilter;
        window.clearFilters = clearFilters;
        window.previewResult = previewResult;
        window.closePreview = closePreview;
        window.openResult = openResult;
        window.addNewLocation = addNewLocation;
        window.removeLocation = removeLocation;
        window.moveLocationUp = moveLocationUp;
        window.moveLocationDown = moveLocationDown;
        window.regenerateFlowLocation = regenerateFlowLocation;
        window.regenerateNPC = regenerateNPC;
        window.removeNPC = removeNPC;
    </script>

    <!-- Initialize Changelog System -->
    <script type="module">
        import { initializeChangelog } from './assets/js/changelog.js';
        
        // Initialize changelog after DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                initializeChangelog();
            });
        } else {
            // DOM already loaded
            initializeChangelog();
        }
    </script>
    
    <!-- Initialize Command History System -->
    <script type="module">
        import {
            generateHistory,
            npcHistory,
            searchHistory,
            GenerateEncounterCommand,
            GenerateNPCCommand,
            FilterChangeCommand,
            SearchCommand,
            getActiveHistory,
            executeInContext,
            undoInContext,
            redoInContext,
            canUndoInContext,
            canRedoInContext
        } from './assets/js/command-history.mjs';
        
        // Initialize command history UI
        function initializeCommandHistory() {
            // Setup keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                // Ctrl+Z for undo
                if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    window.undoLastAction();
                }
                // Ctrl+Shift+Z or Ctrl+Y for redo
                if ((e.ctrlKey && e.shiftKey && e.key === 'Z') || (e.ctrlKey && e.key === 'y')) {
                    e.preventDefault();
                    window.redoLastAction();
                }
            });
        }
        
        // Undo last action in current context
        window.undoLastAction = function() {
            const success = undoInContext();
            const context = window.currentPage || 'generate';
            if (success) {
                console.log(`‚úÖ Undo successful (${context} context)`);
            } else {
                console.log(`‚ö†Ô∏è Nothing to undo in ${context} context`);
            }
        };
        
        // Redo last action in current context
        window.redoLastAction = function() {
            const success = redoInContext();
            const context = window.currentPage || 'generate';
            if (success) {
                console.log(`‚úÖ Redo successful (${context} context)`);
            } else {
                console.log(`‚ö†Ô∏è Nothing to redo in ${context} context`);
            }
        };
        
        // Function to capture complete encounter state
        function captureEncounterState() {
            const encounterDisplay = document.getElementById('encounterDisplay');
            const npcInfoDisplay = document.getElementById('npcInfoDisplay');
            
            return {
                // Capture the actual generated data
                encounterFlow: window.currentEncounterFlow ? JSON.parse(JSON.stringify(window.currentEncounterFlow)) : null,
                // Capture the HTML content for exact restoration
                encounterHTML: encounterDisplay ? encounterDisplay.innerHTML : '',
                npcHTML: npcInfoDisplay ? npcInfoDisplay.innerHTML : '',
                // Capture current page state if needed
                currentPage: window.currentPage || 'generate',
                timestamp: Date.now()
            };
        }
        
        // Function to restore complete encounter state
        function restoreEncounterState(state) {
            if (!state) {
                // Clear everything
                const encounterDisplay = document.getElementById('encounterDisplay');
                const npcInfoDisplay = document.getElementById('npcInfoDisplay');
                if (encounterDisplay) encounterDisplay.innerHTML = '';
                if (npcInfoDisplay) npcInfoDisplay.innerHTML = '';
                window.currentEncounterFlow = null;
                return;
            }
            
            // Restore the data
            window.currentEncounterFlow = state.encounterFlow;
            
            // Restore the HTML displays
            const encounterDisplay = document.getElementById('encounterDisplay');
            const npcInfoDisplay = document.getElementById('npcInfoDisplay');
            
            if (encounterDisplay) {
                encounterDisplay.innerHTML = state.encounterHTML;
                
                // Re-attach event listeners for any interactive elements
                const generateButtons = encounterDisplay.querySelectorAll('.generate-npc-btn');
                generateButtons.forEach(btn => {
                    const locationIndex = parseInt(btn.dataset.locationIndex);
                    const npcIndex = parseInt(btn.dataset.npcIndex);
                    btn.addEventListener('click', function() {
                        if (window.currentEncounterFlow && 
                            window.currentEncounterFlow.locations && 
                            window.currentEncounterFlow.locations[locationIndex] &&
                            window.currentEncounterFlow.locations[locationIndex].npcs &&
                            window.currentEncounterFlow.locations[locationIndex].npcs[npcIndex]) {
                            const npc = window.currentEncounterFlow.locations[locationIndex].npcs[npcIndex];
                            generateNPCFromEncounter(npc.species, npc.subspecies);
                        }
                    });
                });
                
                // Re-attach location detail click handlers
                const locationCards = encounterDisplay.querySelectorAll('.location-card');
                locationCards.forEach(card => {
                    const locationIndex = parseInt(card.dataset.locationIndex);
                    card.addEventListener('click', function(e) {
                        if (!e.target.closest('.generate-npc-btn')) {
                            if (window.currentEncounterFlow && 
                                window.currentEncounterFlow.locations && 
                                window.currentEncounterFlow.locations[locationIndex]) {
                                showLocationDetail(window.currentEncounterFlow.locations[locationIndex], locationIndex);
                            }
                        }
                    });
                });
            }
            
            if (npcInfoDisplay) {
                npcInfoDisplay.innerHTML = state.npcHTML;
            }
        }
        
        // Wrap original generateEncounter to use command pattern with state capture
        const originalGenerateEncounter = window.generateEncounter;
        window.generateEncounter = function() {
            const command = new GenerateEncounterCommand(
                () => {
                    // Call original generate function
                    const result = originalGenerateEncounter();
                    return result;
                },
                captureEncounterState,
                restoreEncounterState
            );
            
            // Execute the command in generate context (this will capture before/after states)
            return generateHistory.execute(command);
        };
        
        // Function to capture complete NPC state
        function captureNPCState() {
            const npcDisplay = document.getElementById('npcDisplay');
            const npcInfoDisplay = document.getElementById('npcInfoDisplay');
            
            return {
                // Capture the actual generated NPC data
                npcData: window.currentNPC ? JSON.parse(JSON.stringify(window.currentNPC)) : null,
                // Capture the HTML content for exact restoration
                npcHTML: npcDisplay ? npcDisplay.innerHTML : '',
                npcInfoHTML: npcInfoDisplay ? npcInfoDisplay.innerHTML : '',
                timestamp: Date.now()
            };
        }
        
        // Function to restore complete NPC state
        function restoreNPCState(state) {
            if (!state) {
                // Clear everything
                const npcDisplay = document.getElementById('npcDisplay');
                const npcInfoDisplay = document.getElementById('npcInfoDisplay');
                if (npcDisplay) npcDisplay.innerHTML = '';
                if (npcInfoDisplay) npcInfoDisplay.innerHTML = '';
                window.currentNPC = null;
                return;
            }
            
            // Restore the data
            window.currentNPC = state.npcData;
            
            // Restore the HTML displays
            const npcDisplay = document.getElementById('npcDisplay');
            const npcInfoDisplay = document.getElementById('npcInfoDisplay');
            
            if (npcDisplay) {
                npcDisplay.innerHTML = state.npcHTML;
            }
            
            if (npcInfoDisplay) {
                npcInfoDisplay.innerHTML = state.npcInfoHTML;
            }
        }
        
        // Wrap NPC generation to use command pattern with state capture
        // Store original function reference
        let originalGenerateNPC = null;
        
        // Wait for generateNPC to be defined, then wrap it
        function wrapNPCGeneration() {
            if (typeof window.generateNPC === 'function' && !originalGenerateNPC) {
                originalGenerateNPC = window.generateNPC;
                
                window.generateNPC = function() {
                    const command = new GenerateNPCCommand(
                        () => {
                            // Call original generate function
                            const result = originalGenerateNPC.apply(this, arguments);
                            return result;
                        },
                        captureNPCState,
                        restoreNPCState
                    );
                    
                    // Execute the command in NPC context
                    return npcHistory.execute(command);
                };
                
                console.log('‚úÖ NPC generation wrapped with command pattern');
            }
        }
        
        // Try to wrap immediately and also after a delay
        wrapNPCGeneration();
        setTimeout(wrapNPCGeneration, 100);
        setTimeout(wrapNPCGeneration, 500);
        
        // Wrap filter changes to use command pattern
        const originalToggleFilter = window.toggleFilter;
        window.toggleFilter = function(type, value) {
            const filterMap = {
                'environment': 'env',
                'locationType': 'location',
                'setting': 'setting'
            };
            
            // Capture old state BEFORE any changes
            const oldFilters = JSON.parse(JSON.stringify(window.activeFilters));
            
            // Call original to compute new state
            originalToggleFilter(type, value);
            
            // Capture new state AFTER the toggle
            const newFilters = JSON.parse(JSON.stringify(window.activeFilters));
            
            // Restore to old state (so execute() can apply the change)
            window.activeFilters = oldFilters;
            
            // Create command with both states
            const command = new FilterChangeCommand(
                type,
                oldFilters,
                newFilters,
                (filterType, filters) => {
                    // This function applies a filter state
                    window.activeFilters = filters;
                    // Update UI
                    document.querySelectorAll('.filter-tags .filter-tag').forEach(tag => {
                        const tagType = tag.dataset.type;
                        const tagValue = tag.dataset.value;
                        const filterKey = filterMap[tagType] || tagType;
                        const isActive = filters[filterKey]?.includes(tagValue);
                        tag.classList.toggle('active', isActive);
                    });
                    window.performSearch();
                }
            );
            
            // Execute command through search history (filters affect search)
            searchHistory.execute(command);
        };
        
        // Initialize after DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeCommandHistory);
        } else {
            initializeCommandHistory();
        }
        
        // Expose for debugging
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            window.__commandHistory = commandHistory;
        }
    </script>
</body>
</html>
